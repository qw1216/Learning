在面向对象中没有理解到什么是面向过程以及什么是面向对象如何使用
es6中的类和对象: 
面向对象特点: 抽取(对象)对象共用的属性和方法组织(封装)成为一个类(模版)
此时这个类(模版)中有这写对象共用的属性和行为,是泛指的某一大类
我们可以对这个类进行实例化,通过这个类不断产生新的对象出来,获取类的对象
面向对象考虑的是有哪些对象,按照面向对象的思维特点,不断创建对象,使用对象

在js中,对象是一组无序的相关属性和方法的集合,所有事物都是对象,字符串,数组,函数,数值
对象是由属性和方法组成的, 属性: 事物的特征在对象中用属性来表示, 例如年龄多少,性别
对象中的方法: 就是事物的行为.在对象中用方法来表示: 例如可以唱歌,就是可以做什么事情

es6新增class: 只要使用class关键字声明的它就是一个类,之后以这个类来实例化对象
calss 类抽象类对象的公共部分,它是泛指的一大类(class)
对象是特指某一个,是通过类(class)实例化一个具体的对象
1. 创建类 class Star { }  / 2. 利用类创建对象 new Star();  / 必须使new来创建 
在类里面非常重要的函数 constructor() 构造函数
constructor()方法是类的构造函数,(用于传递参数,返回实例对象),通过new命令生成对象实例时,自动调用该方法,如果没显示定义,类内部会自动给我们创建一个constructor(),这样就可以不使用return来返回结果了,这要new了生成实例时,就会自动调用
在es6中,所有类里的函数都可以不用加function
在es6中,所有的函数不需要添加function
在constructor()函数里面的this指向的是我创建的实例
当我们在调用的时候一定要注意,一定要加new来调用
在calss类中必须有constructor()函数,如果不写,内部会自动生成
在类中添加共有方法: 只需要把方法或函数直接写到类里就行

类的继承: 子类是可以继承父类的一些属性和方法的
类的继承: 子类使用extends,既可以继承父类的所有属性和方法 son extends father
super()关键字: 用于访问调用对象父类上的函数,可以调用父类构造函数,也能调用普通函数 
如果在子类使用super(),即子类可以使用父类的constructor()和普通函数
super()关键字也可以调用父类的普通函数
在继承中,如果实例化子类输入一个方法,先看子类有没有这个方法,有就先执行子类的方法
在继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就指向父类的方法
在继承中,如果子类和父类同时都具有方法,遵循的原则是: 就近原则
子类可以继承父类的一些方法,同时子类还可以扩展自己独有的方法
在类里面要求: 必须先有了,super调用完之后,才能使用子类中的this
super 必须在子类this之前调用,先有super才能对子类的this做操作

类和对象的注意点: 在es6中类没有变量提示,所以必须先定义类,才能通过类实例化对象
类里面共有的属性和方法一定要添加this使用
类里面的this指向问题: constructor里面的this指向的是 创建的实例对象
已经记住的单词: constructor..extends..super,这部分基本能理解

晚上八点开始复习Es6
类就是对象的模版,对象就是类的实例
new了一下构造函数会执行四件事情:
第一: 首先会创建一个空的对象,然后第二步让里面的this会指向这个空对象
第三: 就把里面的属性和方法进行赋值操作, 第四,就会返回我们创建的实例对象
所以在构造函数中不需要return, 只要new了就可以把实例对象返回,赋值给新对象

面向对象主要思路: 先把对象的公共部分抽取出来,创建一个类,然后用类生成实例
构造函数中的属性和方法我们称为成员,成员可以添加,成员可以分为两大类:
第一大类: 我们称为实例成员; 第二大类: 我们称为静态成员
实例成员就是构造函数内部通过this添加的成员,构造函数中的 uname age 就是实例成员
实例成员只能通过实例化的对象来访问
第二大类:静态成员: 在构造函数本身上添加的成员 Star.sex 就是静态成员
静态成员只能通过构造函数来访问,不能通过对象实例来访问

构造函数方法很好用,但是存在浪费内存的问题
当我们在创建一个对象的时候,方法就是一个函数,函数属于复杂数据类型,当我们在创建一个新的对象的时候,它会单独的开辟一个内存空间来存放复杂数据类型,如果我们创建两个实例对象,系统就会新开辟两个新的空间来存放,来存放同一个函数,所以构造函数存在浪费内存

我们希望所有的对象使用同一个函数,这样就比较节省内存,那么我们需要怎样做呐?
原型对象: prototype: 有了prototype构造函数通过原型分配的函数是所有对象 (共享的)
每一个构造函数都有一个prototype属性,prototype指向另一个对象,这个prototype就是一个对象,这个对象的所有属性和方法,都会被构造函数所拥有
可以把一些不变的方法,直接定义在prototype对象上,这样所有对象的实例就可以共享方法
star.prototype.sing = fucntion () {.......} 把共有的方法放在这个原型对象上,现在不论常见多少个实例对象,它们不会在开辟空间来存放,而是到这个原型对象上面去找,这样就实现共享

 原型是什么? (原型是prototype原型对象,每一个对象都有prototype原型)
原型的作用是什么? (就是共享相同的方法,节约内存)
一般情况下,我们的公共属性定义到构造函数里面
公共的方法要放到原型对象prototype身上,这样就实现了方法的共享,它不会开辟新的内存

三点钟开始复习es6
为什么方法定义到Star构造函数的原型对象上,为什么我利用new创建的对象,可以使用这个方法,在我用new创建的这个对象上也没哟这个方法啊,什么他能够使用这个方法呐?
对象原型__proto__: 对象都会有一个属性__proto__指向构造函数的prototype原型对象,之所以我们对象可以使用构造函数prototype原型对象的属性和方法,就是因为对象有__proto__原型的存在
__proto__里面存的是一个object对象,而这个__proto__指向的就是protype原型对象,虽然对象身上没有方法,但是我这个对象里面有一个__proto__它指向的是这个原型对象prototype,因为原型对象身上有这个方法,所以我这个对象,就可以拿来使用, 在对象对象身上系统自己添加一个__proto__它指向我们构造函数的原型对象prototype,每一个对象身上都有一个__proto__属性,它指向了我们构造函数的原型对象prototype,所以我们就可以使用这个原型对象上面的这个方法, __proto__对象原型和原型对象prototype是等价的
方法的查找规则: 首先先看kfbk对象身上是否是方法,如果有就执行这个对象上的方法,如果没用这个方法,因为有__proto__的存在,就去构造函数原型对象prototype身上去找这个方法
首先我有一个Star构造函数,然后每一个构造函数都有一个原型对象叫做prototype,首先我把方法放到这个Star.原型对象prototype里面,然后我们利用Star构造函数创建了一个对象,叫做kfbk实例对象,虽然这个kfbk实例对象身上没有方法,但是这个kfbk实例对象身上有一个叫作__proto__的对象原型,这个__proto__对象原型,指向的就是我们Star构造函数的原型对象,__proto__指向了构造函数的原型对象prototype,创建的实例对象kfbk就去原型对象prototype查找,有没有方法,如果有,创建的实例对象kfbk就可以使用这个方法,所以我们创建的实例对象可以使用Star构造函数原型对象prototype里面的属性和方法,__proto__它只是内部指向原型对象prototype的一条线路让它指向了原型对象prototype
constructor 构造函数 : 原型对象(__proto__)和构造函数原型对象(prototype)里面都有一个属性constructor属性,constructor我们称为构造函数,因为它指回构造函数本身,
很多情况下我们需要手动的利用constructor 这个属性指回 原来的构造函数
如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回回来的构造函数



原型链:
构造函数, 实例对象, 原型对象三者之间的关系: 首先我们有一个Star构造函数,我们知道每一个构造函数里面都会有一个原型对象,是通过构造函数的prototype(Star.prototype)指向这个原型对象(Star原型对象prototype),同样在原型对象里面也有一个属性constructor,它又指回了这个Star构造函数这是它们之间的关系,我们知道可以通过构造函数来创建一个实例对象只要我new了构造函数就可以创建实例对象,所以我们构造函数又可以指向这个对象实例,我们又知道在这个对象实例中有一个原型叫做__proto__,它指向的是这个Star原型对象prototype,当然实例对象也有一个constructor,它也可以指回我们的构造函数,但是kfbk.__proto__它指向的是原型对象,指向它之后,原型对象里面有一个constructor,它就可以指回构造函数,所以实例对象是靠通过原型对象指回构造函数的,Star原型对象prototype它也是一个对象,只要是对象就有__porto__原型的存在,此时这个Star原型对象prototype.__proto__指向的是谁呐,原来Star原型对象里面也有一个__proto__,它指向的是我们大写的Object原型对象prototype,(Object.prototype),只要是原型 __proto__,它指向的都是原型对象prototype,接着大写的Object里面的原型对象是由谁创建出来的呐?毫无疑问是通过大写的: Object构造函数创建出来的,那么Object构造函数的Object.protitype就指向Object原型对象prototype,同样道理在这个Object原型对象里面还有一个constructor(Object原型对象.constructor)在指回这个Object构造函数,那么我们Object原型对象prototype它里面的__proto__又指向的是谁呐?Object原型对象的__proto__指向的是为 ( null )这里就到最顶层, / 我们kfbk对象实例里面有一个__proto__原型,它指向的是我们创建的构造函数Star原型对象prototype,那Star原型对象prototype也是一个对象,它里面也有一个__proto__,那么这个原型它指向的是Object原型对象prototype,那么Object原型对象也是一个对象,里面也有一个__proto__,它指向的是null,我们发现里面有许许多多的原型,它们组合成了一条链,所以我们称为原型链,有了这个原型链后面我们在访问对象实例的时候就提供了一条线路,我们先看对象实例里面有没有成员,如果没有就到Star原型对象看看有没有这个成员,如果还没有,就在往一层去找,看看Object原型对象上有没有,如果在没有往上就返回为null / 总结: 只要是对象它里面都有一个原型__proto__,这个原型指向的是原型对象prototype,我们先看kfbk对象实例它里面的__proto__指向的是Star原型对象prototype,那这个Star原型对象prototype也有一个__proto__,它指向的是我们Object的原型对象,那么Object原型对象里面也有一个__proto__,它指向的结果为 null;

按道理:constructor指向的是我到底是利用哪一个构造函数创建出来的,现在我把这个原型对象来了一个赋值操作,发现consrtuctor并没有指回我们原来的构造函数,而是指向了Object对象,Star.prototype是一个对象,如果采取是点的形式,那就是在这个对象上去添加新的方法,但是我让Star.prototype等于了一个对象,也就是说利用后面的对象把原先的Star.prototype里面的对象给全部覆盖了,覆盖过后,我们的Star.prototype里面就没有constructor这个属性了,也就是说,它把constructor给覆盖掉了

js的成员查找机制(规则)
当访问一个对象的属性(包括方法)时,首先查找这个对象自身有没有该属性
如果没有就查找它的原型(也就是__proto__指向的prototype原型对象)
如果还没有就查找原型对象的原型(Object的原型对象)
依次类推一直找到Object为止(null)
一句话它在查找的时候是按照我们这种原型链的机制去查找的
如果实例对象已经有这个成员了,然后Star原型对象上也有这个成员,它会遵循就近原则执行实例对象上的成员
在Object.prototype原型对象上有一个方法叫做: toString();但是在实例对象上和Star.prototype原型对象上是没有这个方法的,虽然这两个上面没有这个方法,但是我Object.prototype上面有这个方法,根据原型链的查找机制,我实例对象就能够使用这个toString()这个方法

原型对象中this的指向问题:
this指向原则: this到底指向谁只有你调用这个函数的时候才能确定
thsi指向原则: 一般情况下this指向的是我们的调用者
构造函数内部的this指向的是: 对象实例, 是我new的那个构造函数
构造函数原型对象prototype的this指向的是: 对象实例, 是我new的那个构造函数

扩展内置对象
可以通过原型对象,对原来的内置对象进行扩展自定义的方法,比如给数组新增自定义求偶数
Array.prototype.sum = function() {.....} 追加数组求和

继承
Es6之前并没有给我们提供extends继承,我们通过构造函数+原型对象实现继承,组合继承
call()这个方法可以调用函数,并且可以修改函数运行时的this的指向问题
fun.call(thisArg, arr1, arr2)里面有三个参数
第一个参数,thisArg: 当前调用函数this的指向对象,可以让this指向另一个对象
第二里面的arr1, arr2是传递的其他参数
call()方法可以调用函数 / call就是来呼叫这个函数,来调用这个函数
call()可以改变这个函数this的指向 / fun.call(obj)这样就把这个函数的this指向了对象
fun.call(thisArg, arr1, arr2);后面两个参数,当成函数的实参来看,它会传递给上面函数的形参

借用构造函数继承父类型属性
核心原理: 通过call()把父类型的this指向子类的this,这样就可以实现子类继承父类的属性
学习了利用原型对象继承方法: 
学习了利用原型对象继承方法有一个坑: 不要直接把父原型对象赋值给子原型对象,这样赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起来变化

类的本质
class本质还是function函数
类的本质其实是一个函数,我们也可以简单认定为类就是构造函数的另一种写法
构造函数都有的特点:
构造函数有原型对象prototype
构造函数原型对象prototype里面有constructor 指向构造函数本身
构造函数可以通过原型对象添加方法
构造函数创建的实例对象有__proto__原型指向 构造函数的原型对象

Es5新增方法
数组方法 / 字符串方法 / 对象方法
数组方法: forEach(currentValue, index, arr)
forEach()里面有一个回调函数,分别有三个参数,第一参数是每一个数组元素,第二个参数是它的一个索引号,第三个参数就是数组本身
数组方法: filter(currentValue, index, arr)
filter()它也可以来迭代(遍历)这个数组,filter()方法创建一个新的数组,新数组中的元素是通过检查指定数组中是否有符合条件的所有元素,主要用于筛选数组,注意:它直接返回一个新数组
filter()里面有一个回调函数,分别有三个参数,第一参数是每一个数组元素,第二个参数是它的一个索引号,第三个参数就是数组本身, 里面必须使用return来返回最后的结果,用于筛选数组,只要满足条件就能够拿到,只要它返回的是一个新数组,所以他不会影响原来的数组,我们可以声明一个变量把这个新数组接受过来
数组方法: some(currentValue, index, arr)
some()方法用于检测数组中的元素是否满足指定条件,查找数组中是否有满足条件的元素
注意: 它返回一个布尔值,如果查找到这个元素,就返回true,如果查找不到就返回false
注意: 如果找到第一个满足条件的元素,则终止循环,不再继续查找
some()里面有一个回调函数,里面必须使用return来返回最后的结果

filter: 也是查找满足条件的元素 返回的是一个数组 而且是把所有满足条件的元素返回
some: 也是查找满足条件的元素是否存在 返回的是一个布尔值 如果查找多第一个满足条件的就终止循环

some和forEach区别
在some里面遇到 return true; 就会终止遍历迭代,效率跟高
foforEach会把所有的都遍历完,而我们的some如果遇到return true;他就会不在遍历终止
如果我们 return true; 说明我们找到了元素我们就不在遍历,如果return flase; 说明没有找到

trim方法去除字符串两侧空格
trim()去除字符长两侧空格,返回一个新字符,只不过需要一个变量来接受: var str = str.trim();
trim()并不能去除中间的空格只能够去除两边的空格 if (input,value.trim() === '' ); 这样写系统会更严谨一些

Object.defineProperty()方法
Object.defineProperty() 定义新属性或者修改原有的属性
以前的方法是通过: Obj.num = 10; 添加新属性
以前的方法是通过: Obj.name = '卡夫不卡'; 修改里面的属性的
Object.defineProperty(obj, prop, descriptor),里面三个参数: 第一个叫做 object你要给哪一个对象修改它的属性呐,第二个是prop(属性的意思),就是你要修改的是哪一个属性,第三个属性是,目标属性所拥有的特性
Object.defineProperty(Obj, 'num', {value: 1000}) 这样写是在原先的对象上添加一个叫做num的属性,它的值是 1000; 注意: 它的第三个参数必须是对象形式的写
如果该对象已经有了这个属性值的时候,就是相当于是修改了原先的值,如果没有的话就是添加,如果有的话就是修改
如果第三个参数是: writable: flase, 则表示该属性是不可以被修改的如果writable为true,就表示是能够被修改的
如果第三个参数是: enumerable: false; 则表示如果你在遍历的时候,你是拿不到这个属性的
如果第三那参数是: configurable; 则表示目标属性是可以被删除是否可以再次修改特性
如果第三个参数是: configurable: flase; 表示不允许目标属性被删除或者可以再次修改特性

函数的定义方式
可以通过函数声明方式function 关键字(命名函数)
可以利用函数表达式(匿名函数)
通过new Function() 用构造函数定义函数 var fun = new Function(参数1, 参数2, 函数体);
Function里面参数必须都是字符串格式
我们所有的函数实际上都是我们这个 Function函数的一个实例(对象),因为我们可以通过new Function创建函数的
我们的函数也是属于对象的
instanceof 用于检测前者是不是属于后者 / 返回一个布尔值
我们所有的函数都是通过大写的Function创建出来的,我们可以通过new Function创建出函数实例对象,我们实例对象肯定有一个__proto__原型,它指向的是大写Function里面的原型对象 prototype,同时我们大写的Function构造函数里面也有一个,Function.prtotype原型对象,指向我们这个Function原型对象protype, 同时大写的Function原型对象里面肯定也有一个constructor在指回我们这个,大写的Function构造函数,这是它们之间的三角关系,
我们先看,我们函数实例对象里面有没有__proto__原型对象指向我们Function原型对象prototype呐,那在大写的Function原型对象上是否有constructor指回我们大写的Function构造函数呐,所以函数也是对象

函数的调用方式: 
第一: 普通函数 / 直接 fun();调用 / 或者fn.call()方法调用
第二: 对象的方法函数 / 采取对象.的方式调用 / obj.sayHi()方法调用
第三: 构造函数 / 只需要 new Star(),只要你new了构造函数调用一下它,就会产生实例对象
第四: 绑定事件函数 / btn.onclick = fucntion() { } / 点击了按钮就可以调用这个函数
第五: 定时器函数 / setInterval (function() { }, 1000) / 这个函数是定时器自动1秒调用一次
第六: 立即执行函数 / (function(){ }) (); 立即执行函数,会立即执行是自动调用

函数内部this的指向问题
this的指向一般情况下: 是当我们调用函数的时候确定的,调用方法的不同决定了this的指向不同,一般this的指向是我们的调用者
第一: 普通函数的this指向 / 指向的是window / 调用时是 window.fun();
第二: 对象里面的函数(方法)this的指向 / 指向的是对象 / 调用时时 obj.object
第三: 构造函数里面的this指向 / this指向的是创建的实例对象
第四: 构造函数原型对象的函数this指向是 / this指向的也是创建的实例对象
第五: 绑定事件函数的this / 指向的是函数的调用者,btn这个按钮
第六: 定时器函数里面this的指向 / 定时器里面的this指向的是window
第七: 立即执行函数里面的this的指向 / 立即执行函数this也是指向的window

改变函数内部this的指向
js中为我们专门提供了一些函数方法来帮我们更优雅的处理函数内部的this指向问题
改变函数内部this的指向的方法: 常用的有 / bind() / call() / apply()
call()方法: 第一,它可以调用函数 / 第二,它可以改变函数中this的指向
call()的主要作用可以实现继承
apply()方法调用一个函数,简单理解为调用函数的方式,但是它可以改变函数的this指向
apply()里面三个参数,第一个参数是在函数运行时指定的this值,第二个参数是传递的值,必须包含在数组里面,第三个值返回值就是函数的返回值,因为它就是调用函数
apply也是调用函数,第二它也可以改变函数内部的this指向
但是apply它的参数必须是数组形式的(伪数组),想要传递参数必须以数组的方式来传递
apply的主要应用 比如我们可以利用 apply 借助数学()math内置对象求最大值
求数组中的最大值: var max = Math.max.apply(Math, arr);
bind()方法不会调用函数,但是能改变函数内部this指向,返回由指定的this的原函数拷贝
bind()方法返回的是原函数改变this之后产生的新函数
如果有的函数我们不需要立即调用,但是又想改变这个函数内部this的指向
disabled = true; 禁用

call apply bind 总结
相同点: 都可以改变函数内部的this指向
区别点: call和apply都会调用函数,并且改变函数内部this指向
它们之间的区别点传递的参数不一样,call传递参数arr1,apply传递参数是以数组形式[arr]传递
bind它们的区别,不会调用函数,但是可以改变函数内部this的指向,如果遇到一个函数不需要调用,但是想要改变里面this的指向,就可以使用bind()方法
应用场景: call()经常做继承,让子构造函数继承父构造函数属性的时候可以用call()方法
应用场景: apply()经常跟数组有关系,比如可以借助Math数学对象求最大值最小值
应用场景: bind()不调用函数,但是还想改变this指向,比如改变定时器内部的this指向

严格模式
'use strict' / 下面的js 代码会按照严格模式执行代码
严格模式的规划: 
在正常模式中,如果一个变量没有声明就赋值,默认是全局变量,严格模式下禁用这种用法,变量必须先有var命令声明,然后再使用
delete num; 删除元素; / delete
在严格模式下不能随意的删除已经定义好了得变脸
在严格模式下this指向有一定的问题
以前在全局作用域函数中的this指向的是window对象
在严格模式下它里面的this不再是指向window而是指向undefined
以前构造函数不加new也可以调用,只是当成普通函数来调用,this指向全局对象
在定时器里面的this还是指向的是window
严格模式下函数里面的参数不允许有重名的参数
严格模式下不允许在非函数的代码块内声明函数,比如不允许在if或者for语句中写函数

高阶函数
高阶函数是对其他函数进行操作的函数,它接收函数作为参数或者将函数作为返回值输出
函数是一种数据类型,同样可以作为参数,传递给另一个参数使用,最典型的就是作为回调函数

回调函数
被作为实参传入另一函数，并在该外部函数内被调用，用以来完成某些任务的函数，称为回调函数。

闭包
变量根据作用域的不同可以分为两种: 全局变量和局部变量
在函数内部是可以使用全局变量的
但是在函数外部是不可以使用局部变量
当函数执行完毕,本作用域内的局部变量会销毁
闭包(closure)指有权访问另一个函数作用域中变量的函数,闭包就是一个函数
一个作用域可以访问另外一个函数内部的局部变量(这就是闭包)
闭包: 我们fun 函数作用域 访问了另外一个函数 fn 里面的局部变量num就满足闭包的条件
闭包: 我们fn 外面的作用域可以访问fn 内部的局部变量
闭包的主要作用: 延伸了变量的作用范围

递归
如果一个函数在内部可以调用其本身,那么这个函数就是递归函数
函数内部自己调用自己,这个函数就是递归函数
递归函数的作用和循环效果一样,递归很容易发生死循环(由于递归很容易发生栈溢出),所以递归函数必须要添加退出条件 return,因为它不断调用自己,调着调着就成了死循环了

浅拷贝和深拷贝
浅拷贝只是拷贝一层,更深层次对象级别的只拷贝引用
浅拷贝的时候如果数据是基本数据类型,那么就如果直接赋值一样,会拷贝其本身,如果除了基本数据类型之外还有一层对象,那么对于浅拷贝而言就是能拷贝其引用,对象的改变会反应的拷贝的对象上,但是深拷贝就会拷贝多层,即使嵌套了对象,也会拷贝出来
所谓拷贝,就是赋值,把第一个变量赋值给另一变量,就是把变量的内容进行拷贝,把一个对象的值赋给另一个对象,就是把一个对象拷贝一份
浅拷贝它只能够把地址拷贝给新数据,这个地址指向的还是原来地址里面存储的数据,我们修改了拷贝完之后的数据,结果是会影响到以前的数据的,就是因为浅拷贝把我们这个更深层次的对象地址拷贝给了新数据,它们两个指向的是同一个数据你只要修改其中任何一方的一个数据,原来的数据都是会受到影响的
Es6中新增浅拷贝的语法糖: Object.assign(target..sources)可以实现浅拷贝
浅拷贝: Object.assign(obj);第一个参数是拷贝那个对象,第二个参数是你要拷贝的对象是谁
所谓的浅拷贝只是拷贝一层,更深层次对象级别的只拷贝引用,就好比只能拷贝对象的属性,如果遇到更深层次的数据的话它只是把地址拷贝过去了,如果此时修改了拷贝过去的数据,之前的数据是会跟着一起来变的,浅拷贝只是把地址拷贝给新数据

深拷贝:所谓的深拷贝可以拷贝多层,每一个级别的数据我都是可以拷贝的
在深拷贝中如果遇到嵌套的对象,它会新开辟一个空间,现在所谓的深拷贝它会把新开辟的这个空间重新赋值一份新的空间,然后把拷贝完的这个空间给新数据,这样他们两个互不相干扰的新空间,这样我在修改了我新数据里面的数据,就不会在影响我之前的数据里面的内容了,它只能够是修改拷贝过的数据,修改拷贝过后的数据后,之前数据的内容不会发生改变
比如一个对象中的属性: 它们属于普通数据类型,而在这个对象里面在嵌套一个对象,如果遇到这种对象数据类型,先遍历外面的数据,然后在遍历里面的数据,可以使用函数递归来实现拷贝
我们在进行遍历的时候先看看你是属于简单数据类型还是,对象形式的复杂数据类型,如果是简单数据类型,我们可以直接浅拷贝操作就行,如果是对象形式的那还需要在进行拷贝

结构赋值
变量的结构赋值: Es6允许通过数组或者对象的方式,对一组变量进行赋值,这个被称为结构
数组的结构赋值: var ['a', 'b', 'c'] = [1, 2, 3]; 这就是一个结构赋值
对象的结构赋值: var {name, sex, age} = stae;(这里是对象名),输出直接输出 name# react-material

块级作用域
块级声明用于声明在指定块的作用域之外无法访问的变量 / 只能在当前作用域下使用的变量
块级作用域存于 / 函数内部和{}里面的数据
let声明
let的用法与var相同，就可以把变量的作用域限制在当前代码块中
let声明不会被提升，因此通常将 let 声明语句放在封闭代码块的顶部，整个代码块可以访问
禁止重新声明假设作用域中已经存在某个标识符，此时再使用 let 关键字声明它就会抛出错误
同一作用域中不能用let重复定义已经存在的标识符，let声明会抛出错误
但如果当前作用域内嵌另一个作用域，便可在内嵌的作用域中用let声明同名变量
const声明
使用 const 声明的是常量，其值一旦被设定后不可更改，通过 const 声明的常量必须赋值
const 与 let 声明的都是块级标识符，所以常量也只在当前代码块内有效
const 与 let 一旦执行到块外会立即被销毁，常量同样也不会被提升至作用域顶部
在同一作用域用 const 声明已经存在的标识符也会导致语法错误
无论该标识符是使用 var（在全局或函数作用域中），还是 let（在块级作用域中）声明的
const 声明与 let 声明有一处很大的不同，即无论在严格模式还是在非严格模式下，都不可以为 const 定义的常量再赋值
JavaScript 中的常量如果是对象，则对象中的值可以修改
const 声明不允许修改绑定，但允许修改值，这也就意味着用 const 声明对象后，可以修改该对象的属性值
临时死区
let 和 const 声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，即使是相对安全的 typeof 操作符也会触发引用错误
let 和 const 声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，即使是相对安全的 typeof 操作符也会触发引用错误
但在 let 声明的作用域外对该变量使用 typeof 则不会报错，但是值却是：undefined
全局作用域绑定
let 和 const 与 var 的另外一个区别是它们在全局作用域中的行为，当var被用于全局作用域时，它会创建一个新的全局变量作为全局对象（浏览器环境中的 window 对象）的属性，这意味着用 var 很可能会无意中覆盖一个已经存在的全局变量
如果你在全局作用域中使用 let 或 const，会在全局作用域下创建一个新的绑定，但该绑定不会添加为全局对象的属性，换句话说，用 let 或 const 不能覆盖全局变量，而只能遮蔽它
const 和 let 这一新特性还存在一个副作用，即不能在声明变量前访问它们，就算用typeof这样安全的操作符也不行，声明前访问块级绑定会导致错误，绑定还在临时死区（TDZ）中
字符串和正则表达式

摸板字面量
 ECMAScript 6通过模板字面量的方式进行了填补：
多行字符串　一个正式的多行字符串的概念。
多行字符串　一个正式的多行字符串的概念。
HTML转义　向HTML插入经过安全转换后的字符串的能力。
模板字面量最简单的用法，看起来好像只是用反撇号（`）替换了单、双引号
const message = `Hello `
使用模板字面量语法创建了一个字符串，并赋值给 message 变量，这时变量的值与一个普通的字符串并无差异
字符串占位符
模板字面量在你看来可能就是一个普通 JavaScript 字符串的美化版，其实二者真正的区别在于模板字面量中的占位符功能，在一个模板字面量中，你可以把任何合法的 JavaScript 表达式嵌入到占位符中并将其作为字符串的一部分输出到结果中
占位符由一个左侧的${和右侧的}符号组成，中间可以包含任意的JavaScript表达式
cosnt name = '卡夫不卡'；
message = `Hello ${name}`;
console.log(message)
占位符${name}访问本地变量 name 并将其插入到 message 字符串中，然后变量message就会一直保留着替换后的结果
模板字面量可以访问作用域中所有可访问的变量，无论在严格模式还是非严格模式下，尝试嵌入一个未定义的变量总是会抛出错
既然所有的占位符都是 JavaScript 表达式，就可以嵌入除变量外的其他内容，如运算式、函数调用
标签模版
但模板字面量真正的威力来自于标签模板，每个模板标签都可以执行模板字面量上的转换并返回最终的字符串值，标签指的是在模板字面量第一个反撇号（`）前方标注的字符串
展开运算符
展开运算符可以让你指定一个数组，将它们打散后作为各自独立的参数传入函数，JavaScript内建的Math.max()方法可以接受任意数量的参数并返回值最大的那一个
const value1 = 30
const value2 = 50
console.log(Math.max(value1,value2))
如果只处理两个值，那么 Math.max() 非常简单易用， 传入两个值后返回更大的那一个
Math.max()方法不允许传入数组，或者使用apply()方法
展开运算符示例，向 Math.max() 方法传入一个数组，再在数组前添加不定参数中使用的...符号，就无须再调用 apply() 方法了
const value = [3，4，5，6，7]；
console.log(Math.max(...value))
箭头函数
箭头函数没有this、super、arguments 和 new.target 绑定　箭头函数中的 this、super、arguments 及 new.target 这些值由外围最近一层非箭头函数决定
不能通过 new 关键字调用　箭头函数没有[[Construct]]方法，所以不能被用作构造函数，如果通过 new 关键字调用箭头函数
不可以改变this的绑定，函数内部的this值不可被改变，在函数的生命周期内始终保持一致
箭头函数中没有this绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则this绑定的是最近一层非箭头函数的this；否则，this的值会被设置为undefined
不支持arguments对象　箭头函数没有arguments绑定，所以你必须通过命名参数和不定参数这两种形式访问函数的参数
仍然可以在箭头函数上调用call()、apply() 及 bind()方法，但与其他函数不同的是，箭头函数的this值不会受这些方法的影响
当箭头函数只有一个参数时，可以直接写参数名，箭头紧随其后，箭头右侧的表达式被求值后便立即返回，即使没有显式的返回语句，这个箭头函数也可以返回传入的第一个参数
如果函数没有参数，也要在声明的时候写一组没有内容的小括号，就像这样
cosnt name = () => "卡夫不卡"
创建立即执行函数
JavaScript函数的一个流行的使用方式是创建立即执行函数表达式，你可以定义一个匿名函数并立即调用，自始至终不保存对该函数的引用
解构赋值
对象字面量的语法形式是在一个赋值操作符左边放置一个对象字面量，例如：
const node = {
  type：'istrue'
  name；'卡夫不卡'
}
const {type，name} = node // 解构赋值
node.type 的值被存储在名为 type 的变量中；node.name 的值被存储在名为 name 的变量中。此处的语法与第4章中对象字面量属性初始化的简写语法相同，type 和 name 都是局部声明的变量，也是用来从 options 对象读取相应值的属性名称
如果使用var、let或const解构声明变量，则必须要提供初始化程序（也就是等号右侧的值）
解构赋值表达式（也就是=右侧的表达式）如果为null或undefined会导致程序抛出错误。也就是说，任何尝试读取null或undefined的属性的行为都会触发运行时错误
使用解构赋值表达式时，如果指定的局部变量名称在对象中不存在，那么这个局部变量会被赋值为 undefined
const {type，name，value} = node // 没有value数据解构赋值为undefined
使用不同命名的局部变量来存储对象属性的值
const = {type：name，name：type}；
这种语法实际上与传统对象字面量的语法相悖，原来的语法名称在冒号左边，值在右边；现在值在冒号右边，而对象的属性名在左边
数组解构
它使用的是数组字面量，且解构操作全部在数组内完成，而不是像对象字面量语法一样使用对象的命名属性
const colors = ['red'，'blue'，'plink'，'yellow']
cosnt [firstcolor，secondcolor] = colors
使用数组解构赋值语法，就不再需要额外的变量了
let a = 1;
  b = 3;
  [a, b] = [b,a]
  console.log(a);
  console.log(b);
forEach()遍历数组
let arr = [1，2，3]
arr.forEach((value,index)=>{
  // value是每一个数组元素
  // index是索引号
})
filter()创建一个新数组，主要用于筛选数组
filter() 直接返回一个新数组
var arr = [12,35,48,99];
var newArr = arr.filter((value,index)=>{
  // value是每一个数组元素
  // index是索引号
  return value >= 20; // 返回大于20的元素
})
console.log(newArr);
filter 函数中必须有return
some()创建一个新数组，主要用于筛选数组
some() 筛选数组，找到第一个符合的值就停止筛选
var arr = [12,35,48,99];
var newArr = arr.some((value,index)=>{
  // value是每一个数组元素
  // index是索引号
  return value >= 20; // 返回大于35的元素
})
console.log(newArr);
some 函数中必须有 return
字符串方法 trim()
trim()方法会从一个字符串的两端删除空白的字符，主要用于表单验证
trim()方法并不影响原字符串本身，它返回的是一个新字符串
var str = ' na me '; // trim()方法并不会影响中间的空格
var str1 = str.trim(); // 不需要传递参数，并且返回新的字符串
console.log(str1);
if(input.value.trim() == '') {
  alert('请输入内容')；
}
对象的ObjectdefineProperty()定义新属性或修改原属性
Object.defineProperty(obj(修改对象名)，'name'(修改内容，没有就是添加)，{
  
})
Object.defineProperty(obj，'name' { }), 第三个参数是一个对象，有四个选项：
writable：属性表示是否可以重写（是否允许修改），值为布尔值，默认false
enumerable：属性是否被枚举（是否能被遍历出来），值为布尔值，默认为false
configurable： 属性是否能被删除，
严格模式 'use strict'
严格模式中变量名必须使用关键字声明然后再使用
严格模式下的全局作用域中 this 指向的是 undefined
定时器 setTimeout，setInterval 的 this 指向的还是 window
高阶函数
高阶函数是对函数进行操作的函数，它接收函数作为参数，或，将函数作为返回值输出
函数也是一种数据类型，同样可以作为参数使用，可以做回调函数
function fn(a,b, callback) {
  console.log(a+b)
  callback && callback()
}
fn(10,20, function(){
   console.log('调用')
});
闭包
变量作用域，变量根据作用域的不同分为两种：全局变量和局部变量
函数内部可以使用全局变量
函数外部不可以使用局部变量
函数执行完毕，本作用域的局部变量会销毁
闭包指有权访问另一个函数作用域中变量的函数，闭包就是一个函数
一个作用域可以访问另一个函数内部的局部变量
function fun() {
            num = 10;
            function fn() {
                console.log(num); // fn访问了fun里的局部变量
            }
            fn()
        }
        fun(）
